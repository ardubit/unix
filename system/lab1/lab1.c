/*
Частина 1: Функції послідовного вводу-виводу
Скласти програму, яка:
-----------------------------
- Отримує аргументами командної строки два імені файлів
- Перший файл відкриває для читання, другий до перезапису, або створює, якщо
його не існує (для створення використати атрибути 0644)
- Послідовно читає дані з першого файлу буферами фіксованого об’єму (наприклад
512 байт) та записує у другий.
- Перед записом із вмістом буферу проводить таке перетворення – усі рядкові
літери латинського алфавіту перетворює на відповідні прописні. Для цього
розрахувати відповідний зсув за таблицею ASCII (див. man ascii).
- В процесі перезапису проводить підрахунок перезаписаних байт, та наприкінці
виводить у вихідний потік сумарний обсяг переписаних даних.

Частина 2: Функції мультиплексованого вводу-виводу
Скласти програму, яка:
-----------------------------
- Отримує аргументом командної строки довільний строковий ідентифікатор.
- Налаштовує системний виклик select для очікування читання у вхідному потоці
(файловий дескріптор STDIN_FILENO) з таймаутом 5 секунд.
- При отриманні можливості читання, прочитати з потоку буфер довжиною не більше
1024 байта та вивести його у вихідний потік з поміткою у вигляді ідентифікатора
п.1.
- При спливанні таймауту, вивести у потік помилок повідомлення про це з
поміткою у вигляді ідентифікатора п.1 та знову налаштувати системний виклик
select (п.2).
- Протестувати роботу програми отримуючи через вхідний потік результати вводу з
клавіатури.

open, creat, close, read, write, fsync, fseek, select, poll, errno, strerror.
*/

// char* strerror(int errno);
// errno - глобальна зміна, що містить код помилки, функція повертає текстовий
// опис помилки

// gcc -o lab1 lab1.c
// ./lab1 _in _out
// scp -P 6022 lab1.c dm21mx26@ee.kpi.ua:/home/students/dm21mx26/lab1

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define SIZE 512

int main(int argc, char const *argv[]) {
  // Отримує аргументами командного рядка (два імені файлів)
  if (argc == 1) {
    printf("Помилка! Вкажіть файли: in, out \n");
    return 1;
  } else {
    printf("Виконання: %s \n", argv[0]);
  }

  if (argc != 3)
  {
    printf("Помилка! Вкажіть вхідний та вихідний файли: in, out \n");
    return 1;
  }
  
  // Перший файл відкрити для читання, другий до перезапису або створити,
  // якщо його не існує (для створення використати атрибути 0644)
  int fd_in = open(argv[1], O_RDONLY);
  if (!fd_in) // -1 or NULL
  {
    printf("Error: %s\n", strerror(errno));
    printf("Помилка відкриття файлу для читання! %s \n", argv[1]);
    return 1;
  } else {
    printf("Файл %s відкрито для читання \n", argv[1]);
  }

  // Відкрити _out перезапис або створити
  int fd_out = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644);
  if (!fd_out) {
    printf("Error: %s\n", strerror(errno));
    printf("Помилка відкриття файлу для читання! %s \n", argv[2]);
    return 1;
  } else {
    printf("Файл %s відкрито для запису \n", argv[2]);
  }

  /*
  - Послідовно читає дані з першого файлу буферами фіксованого об’єму
  (наприклад 512 байт) та записує у другий.
  - Перед записом із вмістом буферу проводить таке перетворення – усі рядкові
  літери латинського алфавіту перетворює на відповідні прописні. Для цього
  розрахувати відповідний зсув за таблицею ASCII (див. man ascii).
  - В процесі перезапису проводить підрахунок перезаписаних байт, та наприкінці
  виводить у вихідний потік сумарний обсяг переписаних даних.
  */

  char buffer[SIZE];

  // Контекст пам'яті
  size_t bytes;
  int counter = 0;

  printf("sizeof(size_t): %zd bytes\n", sizeof(size_t));
  printf("sizeof(char): %zd bytes\n", sizeof(char));

  while ((bytes = read(fd_in, buffer, SIZE)) > 0) {
    printf("read() returns: %zd\n", bytes);
    printf("Зміст вхідного файлу: %s\n", buffer);
    printf("Перетворення: \n");

    for (size_t i = 0; i < bytes; i++) {
      printf("%c ->\t", buffer[i]);
      if (islower(buffer[i])) {
        buffer[i] = toupper(buffer[i]);
        printf("%c\t", buffer[i]);
      }
    }

    counter += bytes;
  };

  // Запис у файл
  write(fd_out, buffer, sizeof(bytes) - 1);

  // Вивід у потік STDOUT
  printf("\n");
  write(STDOUT_FILENO, buffer, sizeof(bytes) - 1);

  printf("\nОбсяг переписаних даних, (байт): %d\n", counter);
  close(fd_in);
  close(fd_out);

  // Тестування
  printf(" *** Тестування *** \n");

  // Відкрити _in читання
  int file_test = open(argv[2], O_RDONLY); // O_RDONLY,
  if (!file_test)                          // file_in == NULL
  {
    printf("Error: %s\n", strerror(errno));
    printf("Помилка відкриття файлу для читання! %s \n", argv[2]);
    return 1;
  } else {
    printf("Файл %s відкрито для читання \n", argv[2]);
  }

  bytes = 0;
  while ((bytes = read(file_test, buffer, SIZE)) > 0) {
    // Вивести дані в термінал
    // write(STDOUT_FILENO, buffer, sizeof(bytes));
    printf("Зміст вихідного файлу: %s\n", buffer);
  }

  return 0;
}
