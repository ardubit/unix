/*
Частина 1: Функції послідовного вводу-виводу
Скласти програму, яка:
-----------------------------
- Отримує аргументами командної строки два імені файлів
- Перший файл відкриває для читання, другий до перезапису, або створює, якщо його не існує (для створення використати атрибути 0644)
- Послідовно читає дані з першого файлу буферами фіксованого об’єму (наприклад 512 байт) та записує у другий.
- Перед записом із вмістом буферу проводить таке перетворення – усі рядкові літери латинського алфавіту перетворює на відповідні прописні. Для цього розрахувати відповідний зсув за таблицею ASCII (див. man ascii).
- В процесі перезапису проводить підрахунок перезаписаних байт, та наприкінці виводить у вихідний потік сумарний обсяг переписаних даних.

Частина 2: Функції мультиплексованого вводу-виводу
Скласти програму, яка:
-----------------------------
- Отримує аргументом командної строки довільний строковий ідентифікатор.
- Налаштовує системний виклик select для очікування читання у вхідному потоці (файловий дескріптор STDIN_FILENO) з таймаутом 5 секунд.
- При отриманні можливості читання, прочитати з потоку буфер довжиною не більше 1024 байта та вивести його у вихідний потік з поміткою у вигляді ідентифікатора п.1.
- При спливанні таймауту, вивести у потік помилок повідомлення про це з поміткою у вигляді ідентифікатора п.1 та знову налаштувати системний виклик select (п.2).
- Протестувати роботу програми отримуючи через вхідний потік результати вводу з клавіатури.

open, creat, close, read, write, fsync, fseek, select, poll, errno, strerror.
*/

// gcc -o lab1 lab1.c
// ./lab1 _in _out
// scp -P 6022 lab1.c dm21mx26@ee.kpi.ua:/home/students/dm21mx26/lab1

#include <stdio.h>
#include <ctype.h>

int main(int argc, char const *argv[])
{
    // - Отримує аргументами командної строки два імені файлів
    if (argc == 1)
    {
        printf("Помилка! Вкажіть файли: _in, _out \n");
        return 1;
    }
    else
    {
        printf("Виконання: %s \n", argv[0]);
    }

    // - Перший файл відкриває для читання, другий до перезапису,
    // або створює, якщо його не існує (для створення використати атрибути 0644)

    // Відкрити _in читання
    FILE *file_in;
    file_in = fopen(argv[1], "rb"); // O_RDONLY,

    // file_in == NULL
    if (!file_in)
    {
        printf("Помилка відкриття файлу для читання! %s \n", argv[1]);
        return 1;
    }
    else
    {
        printf("Файл %s відкрито для читання \n", argv[1]);
    }

    // Відкрити _out перезапис або створити
    FILE *file_out;
    file_out = fopen(argv[2], "wb");
    if (!file_out)
    {
        printf("Помилка відкриття файлу для читання! %s \n", argv[2]);
        return 1;
    }
    else
    {
        printf("Файл %s відкрито для запису \n", argv[2]);
    }

    /*
    - Послідовно читає дані з першого файлу буферами фіксованого об’єму (наприклад 512 байт) та записує у другий.
    - Перед записом із вмістом буферу проводить таке перетворення – усі рядкові літери латинського алфавіту перетворює на відповідні прописні.
    Для цього розрахувати відповідний зсув за таблицею ASCII (див. man ascii).
    - В процесі перезапису проводить підрахунок перезаписаних байт, та наприкінці виводить у вихідний потік сумарний обсяг переписаних даних.
    */

#define BUFFER 512
    char buffer[SIZE];

    // Контекст пам'яті
    size_t bytes_r;

    int counter = 0;

    printf("Size: %zd bytes\n", sizeof(size_t));
    printf("Size: %zd bytes\n", sizeof(char));

    do
    {
        // returns the number of items successfully read
        bytes_r = fread(buffer, 1, SIZE, file_in);
        for (size_t i = 0; i < bytes_r; i++)
        {
            printf("%c\t", buffer[i]);
            if (islower(buffer[i]))
            {
                buffer[i] = toupper(buffer[i]);
                printf("%c\t", buffer[i]);
            }
        }

        printf("\n fread return: %zd", bytes_r);
        fwrite(buffer, 1, bytes_r, file_out);
        counter += bytes_r;

    } while (bytes_r);

    printf("\n Обсяг переписаних даних, (байт): %d\n", counter);
    fclose(file_in);
    fclose(file_out);

    return 0;
}
